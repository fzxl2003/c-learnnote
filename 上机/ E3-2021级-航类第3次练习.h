/*
 https://accoding.buaa.edu.cn/contest-ng/index.html#/821
E3-2021级-航类第3次练习
 A 数数逆序对  条件加循环
 B 判断完全数  求因子加和
 C 求e的近似值
 D 统计胜场数  注意输出方式
 E 直线数局
 F 溢0数  // 目前未知错误
 G 高精度加法   //字符串加法
 H zhn の money  //按要求分解数字（使数字能表示任意数字）  //代码详见鬼谷子的钱袋.h
 I 林士谔算法  仅需添加输入输出
 J 测评机没有 sqrt() ！ //二分法开根   //代码详见二分法开方.h
 K 荷家军 进攻 汉诺塔   //汉诺塔       //代码详见汉诺塔.h



 //字符串加法 详见字符串加法.h


 //按要求分解数字（使数字能表示任意数字）
首次读题没有什么思路，毕竟也是在\text{神奇的解法}神奇的解法里的，多次读题之后，才发现这到题的正解。

简化题目：
给定整数NN，求至少需要MM个数，使其和可以分别为1……N-11……N−1,求MM和数列。

分析题目：
通过简化题目，我们不难发现这就是一个分治的题目，并且题目的范围貌似已经提示的很明确了。1≤m ≤10000000001≤m≤1000000000，用普通的枚举，搜索，甚至dpdp，都一定会超时，唯独O(log N)O(logN)的二分不会超时。
深入分析：
我们拿样例来解释：
3可以被分解成1和2，这不是废话吗
我们在取一个数作为例子，例如，我们取10这个数。
10 可以分解成5和5，在拆开5后得到3和2，然后在把2拆成1和1。
最后可以得到10被拆解成了1,1,3,5。
也就是说，我们对一个N，可以每一次都对它进行N/2的操作，直到为N被分解成0为止。
程序实现：
对于每个值的存储，我们开一个数组，用来每次N/2的数字，然后倒序输出。
以下为本题核心代码
while(m)
	{
		a[++k]=(m+1)/2;
		m/=2;
	}
数组因为是从大到小存储的，所以我们要倒序输出
代码如下
#include<cstdio>
int a[200001];
int main()
{
	int m,k=0;
	scanf("%d",&m);
	while(m)
	{
		a[++k]=(m+1)/2;
		m/=2;
	}
	printf("%d\n",k);
	for(int i=k;i>=1;i--)
		printf("%d ",a[i]);
	putchar('\n');
	return 0;
}
总之，本题就是一个难想的题，只要有思路，代码的实现就不会很难



//二分法求根


 */