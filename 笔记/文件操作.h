/*


FILE *fopen(char *filename, char *mode); 打开文件
 int fclose(FILE *fp);  //fp为文件指针     关闭文件
 int fgetc (FILE *fp);    字符读取函数
 int fputc ( int ch, FILE *fp ); 字符写入函数 ch 为要写入的字符，fp 为文件指针
char *fgets ( char *str, int n, FILE *fp );   读字符串函数  str 为字符数组，n 为要读取的字符数目，fp 为文件指针。
int fputs( char *str, FILE *fp ); 写字符串函数     str 为要写入的字符串，fp 为文件指针。
 int fscanf ( FILE *fp, char * format, ... );
 int fprintf ( FILE *fp, char * format, ... );    格式化读写    fp 为文件指针，format 为格式控制字符串，... 表示参数列表。
  long ftell(FILE *stream);
        ⚫ 作用：返回stream所指向的文件的当前位置（相对于文件头部的偏移量）
        ⚫ 返回值：成功返回相对于文件头部的偏移量，出错则返回-1L
 void rewind(FILE *stream);
        ⚫ 作用：移动文件位置指示器到给定文件流的起始，
        等价于：fseek(stream, 0, SEEK_SET);
 int feof(FILE *stream);
        ⚫ 作用：检查上一次读写操作是否已抵达给定文件流的结尾
        ⚫ 返回值：出错则返回-1L，若已抵达流尾则为非零值，否则为0
fseek(fp, ftell(fp), SEEK_SET); 同步文件状态
打开文件
 1.函数 fopen()
 2.函数声明  FILE *fopen(char *filename, char *mode);
          filename为文件名（包括文件路径），mode为打开方式，它们都是字符串。
 3.返回值：返回文件指针(FILE *fp)
           比如  FILE *fp = fopen("demo.txt", "r");
           若文件打开出错，返回NULL;
 4.文件打开方式
     包含读写权限（必须指明）、读写方式（默认为t，可以不指明）
     1.控制读写权限的字符串（必须指明）
        打开方式	    说明
        "r"     	以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。
        "w"	        以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。
        "a"	        以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。
        "r+"	    以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。
        "w+"	    以“写入/更新”方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。
        "a+"	    以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。
    2.控制读写方式的字符串（可以不写）
        打开方式    	说明
        "t"	        文本文件。如果不写，默认为"t"。
        "b"	        二进制文件。
    3.读写权限和读写方式可以组合使用，但是必须将读写方式放在读写权限的中间或者尾部（换句话说，不能将读写方式放在读写权限的开头）。例如：
        将读写方式放在读写权限的末尾："rb"、"wt"、"ab"、"r+b"、"w+t"、"a+t"
        将读写方式放在读写权限的中间："rb+"、"wt+"、"ab+"
  5.文件打开的常用代码
  if ((fp = fopen(filename, "w")) == NULL)
    {
        printf("can not open file\n");
        return 0;
    }
关闭文件
 1.函数声明：int fclose(FILE *fp);  //fp为文件指针
 2.返回值：文件正常关闭时，fclose() 的返回值为0，如果返回非零值则表示有错误发生。

位置指针
 在文件打开后，c语言自动创建一个位置指针，指向文件头。
 文件每读写一次，位置指针就会移动一次。读写多少就移动多少。
 位置指针必须通过函数来修改，不能随意++或--
 注意和文件指针相互区分
 文件函数调用时均使用文件指针，但读取或写入的具体位置取决于该文件指针的位置指针指向的位置



以字符形式读写文件
 （一）字符读取函数 fgetc
   1.函数声明：int fgetc (FILE *fp);
   2.返回值：读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。
   3.使用char ch=fgetc(fp);
   4.利用fgetc()!=EOF来判断到达文件尾时，必须以文本文件打开 二进制文本需要用!feof()来判断
 （二）字符写入函数 fputc
   1.函数声明：int fputc ( int ch, FILE *fp );  ch 为要写入的字符，fp 为文件指针
   2.返回值：写入成功时返回写入的字符，失败时返回 EOF
   3.注意：
        1) 被写入的文件可以用写、读写、追加方式打开，
        用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。
        如需保留原有文件内容， 并把写入的字符放在文件末尾，就必须以追加方式打开文件。
        不管以何种方式打开，被写入的文件若不存在时则创建该文件。
        2) 每写入一个字符，文件内部位置指针向后移动一个字节。



以字符串形式读写文件(首选)
 （一）读字符串函数 fgets
     1.函数声明：char *fgets ( char *str, int n, FILE *fp );
        str 为字符数组，n 为要读取的字符数目，fp 为文件指针。
     2.返回值：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；
             如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。
     3.注意：
             1.读取到的字符串会在末尾自动添加 '\0'，n 个字符也包括 '\0'。要想读入"Hello" n需要为6
             2.在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。
               fgets最多读取一行数据。若设置的n足够大，就可以读取一行数据

 （二）写字符串函数 fputs
    1.函数声明：int fputs( char *str, FILE *fp );
             str 为要写入的字符串，fp 为文件指针。
    2.返回值：写入成功返回非负数，失败返回 EOF。


以数据块的形式读写文件
 在windows系统下必须以二进制形式打开文件才能以数据块的形式读写文件（若以文本形式打开，会偷偷加'\r'）
 1.读取函数fread()  函数声明 size_t fread ( void *ptr, size_t size, size_t count, FILE *fp );
   写入函数fwrite() 函数声明size_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp );
 2.参数说明：
   ptr 为内存区块的指针，它可以是数组、变量、结构体等。fread() 中的 ptr 用来存放读取到的数据，fwrite() 中的 ptr 用来存放要写入的数据。
   size：表示每个数据块的字节数。
   count：表示要读写的数据块的块数。
   fp：表示文件指针。
   理论上，每次读写 size*count 个字节的数据。
 3.返回值：返回成功读写的块数，也即 count。如果返回值小于 count，则说明部分数据写入失败



 格式化读写文件
 1.函数：fscanf()  fprintf()
 2.函数声明： int fscanf ( FILE *fp, char * format, ... );
            int fprintf ( FILE *fp, char * format, ... );
     fp 为文件指针，format 为格式控制字符串，... 表示参数列表。
     与 scanf() 和 printf() 相比，它们仅仅多了一个 fp 参数（除了读入写入的位置不同，其他的和scanf()printf()一模一样）
 3.返回值：fprintf() 返回成功写入的字符的个数，失败则返回负数。
          fscanf() 返回参数列表中被成功赋值的参数个数。
 4.如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 的作用相同；
      将 fp 设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 的作用相同。


 随机读写文件 位置指针的随意移动
 1.函数rewind() 将位置指针移动到文件开头
   函数声明：void rewind ( FILE *fp );
 2.函数fseek() 将位置指针移动到任意位置
    1.函数声明：int fseek ( FILE *fp, long offset, int origin );
    2.参数说明：1) fp 为文件指针，也就是被移动的文件。
              2) offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。
              3) origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为文件开头、当前位置和文件末尾，每个位置都用对应的常量来表示：
           起始点	常量名	常量值
           文件开头	SEEK_SET	0
           当前位置	SEEK_CUR	1
           文件末尾	SEEK_END	2
    3.fseek() 一般用于二进制文件，在文本文件中由于要进行转换，计算的位置有时会出错。
  3.文件的随机读写
     由于fseek()一般用于二进制文件，所以文件的随机读写一般使用 fread() 和 fwrite()

其他函数
 long ftell(FILE *stream);
        ⚫ 作用：返回stream所指向的文件的当前位置（相对于文件头部的偏移量）
        ⚫ 返回值：成功返回相对于文件头部的偏移量，出错则返回-1L
 void rewind(FILE *stream);
        ⚫ 作用：移动文件位置指示器到给定文件流的起始，
        等价于：fseek(stream, 0, SEEK_SET);
 int feof(FILE *stream);
        ⚫ 作用：检查上一次读写操作是否已抵达给定文件流的结尾
        ⚫ 返回值：出错则返回-1L，若已抵达流尾则为非零值，否则为0



 按照“读写”方式打开的文件，不能在读后立刻写入，也不能在写入后立刻读取，需要“同步文件状态”
    法一 fseek(fp, ftell(fp), SEEK_SET);
    法二 fflush(fp);  在stdio.h头文件中，用来强制将缓冲区中的内容写入文件 *

 */