/*
 一.指针的概念
 1.将内存中字节的编号称为地址（Address）或指针（Pointer）。
 2.内存地址从 0 开始依次增加，
   对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。




 二.指针变量的定义与使用
 1.指针变量：如果一个变量存储了一份数据的指针，我们就称它为指针变量
 2.定义方法:
    int a = 100;    //定义一个int变量（与指针变量的定义无关）
    int *p_a = &a;  //int *表示定义一个指向int变量的指针变量，p_a为指针变量名称
                         &a是变量a的指针，=赋值给了p_a
  指针可以连续被定义  int *a, *b, *c;  //a、b、c 的类型都是 int*
    但是int *a, b, c;  //只有 a 是指针变量，b、c 都是类型为 int 的普通变量：




 3.指针变量的使用：p_a 可以认为就是一个普通变量，直接调用会返回它存储的内容，即它所指向的变量的内存地址
                *p_a  等价于a，调用时返回a的存储内容，对其修改相当于修改a的值
                &p_a  返回p_a的内存地址
                &(*p_a)=p_a
                *(&p_a)=p_a
 4.指针变量的运算
   1.指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算
   2.指针的加法（暂不考虑二维数组指针变量）
      p_a++  //实际上p_a增加了len(int),增加的长度与指针变量所指向的变量类型有关
             //加1代表 指针变量指向内存里的下一个变量
   3.在指向数组的指针变量的加法有意义，其他指针变量的加法毫无意义
   4.同一数组两个指针的减法代表他们之间相差的元素个数
     指针变量的乘法更没意义
 5.指针的比较
 指针间的比较：两个指向同一类型的指针，可以进行==，>,<的比较
 指针与0的比较
    •在指针末指向任何实际的存储单元时，或指针所指向的存储单元已经不存在时，通常将其标记为无效指针 (0）
    •为了表示指针的。在类型上不同于整数类型的 0，在C的标准头文件中定义一个等于0的符号常量NULL
    •数值为 0 或 NULL 的指针不指向任何内容，称为空指针数值。 是唯一可以不将整数转换为指针类型而直接赋给指针变量的整数值.

 三.数组指针（指向数组的指针）
   1.表达式中数组名会被转换成数组第0个变量的内存地址
     在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，
   2.定义方法：
   int arr[] = { 99, 15, 100, 888, 252 };
   int *p = arr;     //本质上p存储的是arr[0]的内存地址
   int *p=&arr[0]    //等价于上一行
   3.数组指针变量的使用（以遍历数组元素为例）
   #include <stdio.h>
    int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){         //len存储的是arr数组元素个数
        printf("%d  ", *(p+i) );  //p+i代表指向arr[i]的指针变量
    }
    printf("\n");
    return 0;}

    等价代码
    #include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){
        printf("%d  ", *p++ );
    }
    printf("\n");
    return 0;
}

  4.关于数组指针的谜题
     假设 p 是指向数组 arr 中第 n 个元素的指针，那么
     *p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素
     *++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。
    (*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。


 四.字符串指针
 1.字符串复习
    1.字符串实质是以'\0'结尾的字符数组
    2."123456" 这样的字符串只能读取，不能更改
      char a[10]="hello"
      等价于char str[]={'h','e','l','l','o','\0'}
    3.输出
       char str[] = "http://c.biancheng.net";
       int len = strlen(str), i;
        printf("%s\n", str); //直接输出字符串
        for(i=0; i<len; i++){  //每次输出一个字符
        printf("%c", str[i]);}
        printf("\n");
 2.指向字符串数组的字符串指针
    char str[] = "http://c.biancheng.net";
    char *pstr = str;    //定义指向str字符串数组的指针变量
    int len = strlen(str), i;
    for(i=0; i<len; i++){  //使用*(pstr+i)
        printf("%c", *(pstr+i));
    }
    printf("\n");
    for(i=0; i<len; i++){ //使用pstr[i]
        printf("%c", pstr[i]);
    }
    printf("\n");
    for(i=0; i<len; i++){  //使用*(str+i)
        printf("%c", *(str+i));  //str在该情况下也是指针变量，但它不能被写入
    }
    printf("\n");
 3.指向字符串的字符串指针
    char *str = "http://c.biancheng.net";
    int len = strlen(str), i;
    printf("%s\n", str);   //直接输出字符串
    for(i=0; i<len; i++){ //使用*(str+i)
        printf("%c", *(str+i));
    }
    printf("\n");
    for(i=0; i<len; i++){ //使用str[i]
        printf("%c", str[i]);
    }
    printf("\n");

    return 0;
}
 3.char str[]="hello"与char *a="hello world";的相同点和区别
    1.调用时完全一致，都可以使用%s输出整个字符串，都可以使用*或[ ]获取单个字符
    2.写入时完全不同，str[]是数组，可以自由修改数据
       a本质是指针变量，只能修改a指向的字符串的第几个元素，由于"hello"这样的字符串实质是常量，不能被修改
       所以不能改变指向变量的值


 五.指针变量作为函数参数
 1.指针变量实质是变量，可以作为函数参数
 2.由于很难向函数传入数组的所有值，
   常用于向函数内传入数组内存地址，
   这样对数组的修改会影响到函数以外
   定义方法：
     函数声明 int max(int *intarr,int len)
            若传入数组，也可以这样声明 int max(int a[],int len)
     函数调用 max(nums, len)   //nums是数组或者指针变量
 3.函数内部不能从参数本身直接判断数组大小，如作为参数的数组的大小不确定，
    应当使用附加参数说明数组的大小



  六.指针作为函数返回值
1.指针变量实质是变量，可以作为函数的返回值
2.函数声明： char *strlong()  //char *可替代成其他变量类型的变量指针（确实没有必要）
3.实例：返回两个字符串中较长的一个
    char *strlong(char *str1, char *str2){
        if(strlen(str1) >= strlen(str2)){
        return str1;
        }else{
        return str2;
        }
        }
    int main(){
        char str1[30], str2[30], *str;
        str1="1123123";
        str2="1143223123";
        str = strlong(str1, str2);
        printf("Longer string: %s\n", str);
        return 0;
        }
4.注意：函数返回的指针请尽量不要指向在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数
     说不定在使用之前就被销毁了


七.二级指针
 1.一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。
 2.定义方法：int a =100;
           int *p1 = &a;
           int **p2 = &p1;  //定义了a的二级指针
           int ***p3 = &p2; //定义了a的三级级指针
           int ****p4 = &p3; //定义了a的四级指针
           。。。。。。。
 3.使用方法：与指针变量一致，别搞混了就行 ***p3等价于*(*(*p3))
 4.实例：
    #include <stdio.h>
   int main(){
    int a =100;
    int *p1 = &a;
    int **p2 = &p1;
    int ***p3 = &p2;
    printf("%d, %d, %d, %d\n", a, *p1, **p2, ***p3);
    printf("&p2 = %#X, p3 = %#X\n", &p2, p3);
    printf("&p1 = %#X, p2 = %#X, *p3 = %#X\n", &p1, p2, *p3);
    printf(" &a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n", &a, p1, *p2, **p3);
    return 0;
     }
   运行结果：
     100, 100, 100, 100
     &p2 = 0X28FF3C, p3 = 0X28FF3C
     &p1 = 0X28FF40, p2 = 0X28FF40, *p3 = 0X28FF40
     &a = 0X28FF44, p1 = 0X28FF44, *p2 = 0X28FF44, **p3 = 0X28FF44
 八.指针数组
 1.定义：保存指针变量的数组
 2.定义方法与使用：
    int a = 16, b = 932, c = 100;
    int *arr[3] = {&a, &b, &c};//定义一个指针数组//也可以不指定长度，直接写作 int *arr[]
    int **parr = arr;//定义一个指向指针数组的指针
    printf("%d, %d, %d\n", *arr[0], *arr[1], *arr[2]);
    printf("%d, %d, %d\n", **(parr+0), **(parr+1), **(parr+2));

输出结果 16, 932, 100
        16, 932, 100
 3.实例解释
    arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。
    parr 是指向数组 arr 的指针，确切地说是指向 arr 第 0 个元素的指针，它的定义形式应该理解为int *(*parr)，括号中的*表示 parr 是一个指针，括号外面的int *表示 parr 指向的数据的类型。arr 第 0 个元素的类型为 int *，所以在定义 parr 时要加两个 *。
    第一个 printf() 语句中，arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 * 才能取得它指向的数据，也即 *arr[i] 的形式。
    第二个 printf() 语句中，parr+i 表示第 i 个元素的地址，*(parr+i) 表示获取第 i 个元素的值（该元素是一个指针），**(parr+i) 表示获取第 i 个元素指向的数据。
 4.与字符串结合的使用
    #include <stdio.h>
    int main(){
    char *str[3] = {
        "c.biancheng.net",
        "C语言中文网",
        "C Language"
    };
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
    }
        运行结果：
            c.biancheng.net
            C语言中文网
            C Language
   //str 中存放的是字符串的首地址，不是字符串本身，字符串本身位于其他的内存区域，和字符数组是分开的。
   //  char *str0 = "c.biancheng.net";
       char *str1 = "C语言中文网";
       char *str2 = "C Language";
       char *str[3] = {str0, str1, str2};  //等价于上述代码的str的定义代码

 九.二维数组指针（指向二维数组的指针）
 1.二维数组在内存中的排列 int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
  在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：
  C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；
  每行中的 4 个元素也是依次存放。数组 a 为 int 类型，
  每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。
 2.可以用一维数组的数组指针去调用二维数组，只需遵循二维数组在内存中的排列规律
 3.定义方法：int (*p)[4] = a;
   括号中的*表明 p 是一个指针，
      它指向一个数组，数组的类型为int [4]
   注意：不能写成int *p[4]，这样应理解为int *(p[4])，p就成了一个指针数组，而不是二维数组指针
 4.加法：由于p代表的类型是int [4],所以p++相当于加4*len(int)，即指向二维数组的下一行
 5.二维数组指针的调用
 若p指向第0行，则*(p+1)+1表示第 1 行第 1 个元素的地址
              *(*(p+1)+1)表示第 1 行第 1 个元素的值

 *(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，
 也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，
 编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；
 就像一维数组的名字，在定义时或者和 sizeof、& 一起使用时才表示整个数组，
 出现在表达式中就会被转换为指向数组第 0 个元素的指针。
 *(*(p+1)+1)表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。
 6.
    int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
    int (*p)[4] = a;
    等价关系：
        a+i == p+i
        a[i] == p[i] == *(a+i) == *(p+i)
        a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)
 7.指针数组和二维数组指针定义的区别
   int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];
    int (*p2)[5];  //二维数组指针，不能去掉括号


 十.函数指针（吃饱了撑的人才用）
        #include <stdio.h>
        int max(int a, int b){//返回两个数中较大的一个
          return a>b ? a : b;
        }
        int main(){
          int x, y, maxval;
          int (*pmax)(int, int) = max; //定义函数指针并赋值 //也可以写作int (*pmax)(int a, int b)
          printf("Input two numbers:");
         scanf("%d %d", &x, &y);
         maxval = (*pmax)(x, y);   //调用
         printf("Max value: %d\n", maxval);
         return 0;
        }
 几个总结
 （1）
 */